clear all
clear workspace
%% Import data from spreadsheet
% Script for importing data from the following spreadsheet:
%
%    Workbook: /Volumes/GoogleDrive/My Drive/Experimental Geochemistry/Yuanyuan/Zircon project/Matlab Figure/D_vs_T_SiO2/MATLAB_Fitting_07012021 copy/DvsTSiO2_source.xlsx
%    Worksheet: Sheet1
%
% Auto-generated by MATLAB on 19-Nov-2021 14:15:32

%% Set up the Import Options and import the data
opts = spreadsheetImportOptions("NumVariables", 48);

% Specify sheet and range
opts.Sheet = "Sheet1";
opts.DataRange = "A2:AV67";

% Specify column names and types
opts.VariableNames = ["VarName1", "exp", "DUMCWGlsStdErr", "DUErrprWGlsStdErr", "DThMCWGlsStdErr", "DThErrorWGlsStdErr", "ngls", "SiO2", "TiO2", "Al2O3", "ZrO2", "Fe2O3", "FeO", "MnO", "MgO", "CaO", "Na2O", "K2O", "ThO2", "UO2", "P2O5", "HfO2", "H2O", "TOTAL", "ZrPpm", "ZrPpm1Sig", "SiERR", "ZrERR", "TiERR", "ThERR", "UERR", "AlERR", "FeERR", "MnERR", "MgERR", "CaERR", "NaERR", "KERR", "HfERR", "PERR", "startingTC", "soakingTC", "naturalZirTK", "naturalZirT1Sigma", "UwtZir","UwtZir1sigError", "ThwtZir", "ThwtZir1sigError", "UwtGls", "UwtGls1sigError", "ThwtGls", "ThwtGls1sigError"];
opts.VariableTypes = ["string", "string", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double"];

% Specify variable properties
opts = setvaropts(opts, ["VarName1", "exp"], "WhitespaceRule", "preserve");
opts = setvaropts(opts, ["VarName1", "exp"], "EmptyFieldRule", "auto");

% Import the data
DvsTSiO2source = readtable("DvsTSiO2_source.xlsx", opts, "UseExcel", false);


%% Clear temporary variables
clear opts

%% 1. calculate M

% define molar masses for oxides
mm.SiO2  = 60.08;
mm.TiO2  = 79.866;
mm.Al2O3 = 101.96;
mm.Fe2O3 = 159.69;
mm.MnO   = 70.9374;
mm.MgO   = 40.3044;
mm.CaO   = 56.0744;
mm.Na2O  = 61.9789;
mm.K2O   = 94.2;
mm.P2O5  = 283.886;
mm.HfO2  = 210.49;
mm.ThO2  = 264.04;
mm.UO2   = 270.03;
mm.ZrO2  = 123.218;
mm.FeO   = 71.844;
mm.Zr    = 91.224;
mm.U     = 238.02891;
mm.Th    = 232.03806;

nSamples = size(DvsTSiO2source,1);
M = zeros(nSamples,2); % first column is value, second column 1sigma abs unct.
T = zeros(nSamples,2); % first column is value, second column 1sigma abs unct.
S.Tin = zeros(2*nSamples+3,2*nSamples+3);
J = zeros(nSamples, 2*nSamples+3); 
S.SiO2 = zeros(nSamples, nSamples);
S.DU   = zeros(nSamples, nSamples);
SiO2 = zeros(nSamples, 1);
DU = zeros(nSamples,1);
DTh = zeros(nSamples,1);

DUMC_mean = zeros(nSamples,1);
DUMC_std = zeros(nSamples,1);
DThMC_mean = zeros(nSamples,1);
DThMC_std = zeros(nSamples,1);
DThDUMC_mean = zeros(nSamples,1);
DThDUMC_std = zeros(nSamples,1);

for iSample = 1:nSamples
    
    data = DvsTSiO2source(iSample,:);
    
    % calculate molar percentages for each oxide. For researchers who report Zr
    % in ppm (ug/g) is also included here. 
    molpct.SiO2  = data.SiO2 / mm.SiO2;
    molpct.TiO2  = data.TiO2 / mm.TiO2;
    molpct.Al2O3 = data.Al2O3/ mm.Al2O3;
    molpct.ZrO2a  = data.ZrO2 / mm.ZrO2; % a stands for researchers who report ZrO2 (wt%)
    molpct.Fe2O3 = data.Fe2O3/ mm.Fe2O3;
    molpct.FeO   = data.FeO  / mm.FeO;
    molpct.MnO   = data.MnO  / mm.MnO;
    molpct.MgO   = data.MgO  / mm.MgO;
    molpct.CaO   = data.CaO  / mm.CaO;
    molpct.Na2O  = data.Na2O / mm.Na2O;
    molpct.K2O   = data.K2O  / mm.K2O;
    molpct.ThO2  = data.ThO2 / mm.ThO2;
    molpct.UO2   = data.UO2  / mm.UO2;
    molpct.P2O5  = data.P2O5 / mm.P2O5;
    molpct.HfO2  = data.HfO2 / mm.HfO2;
    molpct.U     = data.UwtGls / mm.U * 0.0001; %U and Th wt in ppm, convert to wt%, which is ppm/10,000
    molpct.Th    = data.ThwtGls / mm.Th * 0.0001;
    
    Zr.wt        = data.ZrPpm / 10^4;
    Zr.mol       = Zr.wt / mm.Zr;
    molpct.ZrO2b = 3 * Zr.mol; % b stands for researchers who report Zr ppm (ug/g)
    
    molpctVec = cell2mat(arrayfun(@(f) molpct.(f{:}), fieldnames(molpct), 'un', 0));
    % calculate the sum of mol percent of oxides in the glass, to help us calculate the
    % umol/mol for U and Th in glass, each input data array should have
    % different sum of mol percent because of different glass wt%
    molpctSum = sum(molpctVec(~isnan(molpctVec)));
    molnrm.Zra = molpct.ZrO2a / molpctSum;
    molnrm.Zrb = molpct.ZrO2b / molpctSum;
    
    % calculate U and Th in mol% by converting wt% to moles then normalize
    % to 100, output U and Th by mol% in glass
    molregls.U = molpct.U / molpctSum;
    molregls.Th = molpct.Th / molpctSum;
    UmolGls = molregls.U;
    ThmolGls = molregls.Th;
    
    % calculate the sum of mol percent of oxides in the zircon, to help us calculate the
    % umol/mol for U and Th in zircon, output U and Th by mol% in zircon
    wtzir.SiO2 = 32.48; %typical SiO2 and ZrO2 wt% in zircon measurement
    wtzir.ZrO2 = 66.72;
    molpctzir.SiO2 = wtzir.SiO2 / mm.SiO2;
    molpctzir.ZrO2 = wtzir.ZrO2 / mm.ZrO2;
    molpctzir.U = data.UwtZir / mm.U * 0.0001;
    molpctzir.Th = data.ThwtZir / mm.Th * 0.0001;
    molpctzirVec = cell2mat(arrayfun(@(f) molpctzir.(f{:}), fieldnames(molpctzir), 'un', 0));
    molpctSumZir = sum(molpctzirVec(~isnan(molpctzirVec)));
    molreZir.U = molpctzir.U / molpctSumZir;
    molreZir.Th = molpctzir.Th / molpctSumZir;
    UmolZir = molreZir.U;
    ThmolZir = molreZir.Th;
    
    % Using Monte Carlo to calculate standard deviation of DU, DTh, DTh/DU (mol%)
    % for other papers
    %   Generate n samples from a normal distribution
    %     r = ( randn(n,1) * sd ) + mu
    %     mu : mean
    %     sd : standard deviation
    n = 2000000;	% The number of function evaluations

    % --- Generate vectors of random inputs
    % Normal distribution N(mean=U or Th mol% in zircon or glass,sd=representative 1 sigma stdv calculated from papers when they report it)
    stdv.UZir  = 0.222734176 * UmolZir;	%all stdv in mol%
    stdv.ThZir = 0.168006719 * ThmolZir;	
    stdv.UGls  = 0.029038801 * UmolGls;	
    stdv.ThGls = 0.040568198 * ThmolGls;
    
%     % use Luo and Ayers (2009) to test whether the MC loop works or not
% 
%     stdv.UZir  = 0.534831355 * UmolZir;	%all stdv in mol%
%     stdv.ThZir = 0.399470684 * ThmolZir;	
%     stdv.UGls  = 0.070693545 * UmolGls;	
%     stdv.ThGls = 0.064466745 * ThmolGls;
% Normal distribution, will include all the negative numbers for U and Th
% conc in zircon and glass, which is not possible
%     UMCZir = ( randn(n,1) .* stdv.UZir ) + UmolZir;
%     UMCGls = ( randn(n,1) .* stdv.UGls ) + UmolGls;
%     ThMCZir = ( randn(n,1) .* stdv.ThZir ) + ThmolZir;
%     ThMCGls = ( randn(n,1) .* stdv.ThGls ) + ThmolGls;
    
% Lognormal distribution, which will only generage positive numbers for U
% and Th contents in zircon and glass
    UMCZir = random('Lognormal', log(UmolZir), stdv.UZir/UmolZir, [n, 1]);
    UMCGls = random('Lognormal', log(UmolGls), stdv.UGls/UmolGls, [n, 1]);
    ThMCZir = random('Lognormal', log(ThmolZir), stdv.ThZir/ThmolZir, [n, 1]);
    ThMCGls = random('Lognormal', log(ThmolGls), stdv.ThGls/ThmolGls, [n, 1]);
    %hist(UMCZir,50)
   
    % --- Run the Monte Carlo simulation
    DUMC    = UMCZir ./ UMCGls;
    DThMC   = ThMCZir ./ ThMCGls;
    %DThDUMC = DThMC ./ DUMC;

    %   Generate n samples from a normal distribution for DU and DTh
%     DUND = ( randn(n,1) .* std(DUMC) ) + mean(DUMC);
%     DThND = ( randn(n,1) .* std(DThMC) ) + mean(DThMC);
%     DThDUMC = rmoutliers(DThND ./ DUND);
    % Generate n samples from a lognormal distribution for DTh/DU
    DUND = random('Lognormal', log(mean(DUMC)), std(DUMC)/mean(DUMC), [n, 1]);
    DThND = random('Lognormal', log(mean(DThMC)), std(DThMC)/mean(DThMC), [n, 1]);
    DThDUMC = DThND ./ DUND;
    % --- Create a histogram of the results (50 bins)
    
    %hist(DUMC,50);

    % --- Calculate summary statistics
    DUMC_mean(iSample,1) = mean(DUMC);
    DUMC_std(iSample,1) = std(DUMC);
    DThMC_mean(iSample,1) = mean(DThMC);
    DThMC_std(iSample,1) = std(DThMC);
    DThDUMC_mean(iSample,1) = mean(DThDUMC);
    DThDUMC_std(iSample,1) = std(DThDUMC);
    
    % get cation proporations for each oxide. 
    catpct.Si =   molpct.SiO2;
    catpct.Ti =   molpct.TiO2;
    catpct.Al = 2*molpct.Al2O3;
    catpct.Zra =   molpct.ZrO2a;
    catpct.Zrb =   molpct.ZrO2b;
    catpct.Fe = 2*max(molpct.Fe2O3,0) + max(molpct.FeO,0);
    catpct.Mn =   molpct.MnO;
    catpct.Mg =   molpct.MgO;
    catpct.Ca =   molpct.CaO;
    catpct.Na = 2*molpct.Na2O;
    catpct.K  = 2*molpct.K2O;
    catpct.Th =   molpct.ThO2;
    catpct.U  =   molpct.UO2;
    catpct.P  = 2*molpct.P2O5;
    catpct.Hf =   molpct.HfO2;
   
    catpctVec = cell2mat(arrayfun(@(f) catpct.(f{:}), fieldnames(catpct), 'un', 0));
    catpctSum = sum(catpctVec(~isnan(catpctVec)));

    % normalize cations proportions of interest
    catnrm.Na = catpct.Na / catpctSum;
    catnrm.K  = catpct.K  / catpctSum;
    catnrm.Ca = catpct.Ca / catpctSum;
    catnrm.Si = catpct.Si / catpctSum;
    catnrm.Al = catpct.Al / catpctSum;
    
    % calculate M using re-normalized cation proportions
    Mi = (catnrm.Na + catnrm.K + 2*catnrm.Ca)/(catnrm.Si*catnrm.Al);
    M(iSample, 1) = Mi;
    
    % linear uncertainty propagation for M, assuming % unct in Na from probe = % unct
    % in renomalized cation abundance
    dM.dNa = 1/(catnrm.Al * catnrm.Si);
    dM.dK  = 1/(catnrm.Al * catnrm.Si);
    dM.dCa = 2/(catnrm.Al * catnrm.Si);
    dM.dAl = -(catnrm.Na + catnrm.K + 2*catnrm.Ca)/(catnrm.Al^2 * catnrm.Si);
    dM.dSi = -(catnrm.Na + catnrm.K + 2*catnrm.Ca)/(catnrm.Al * catnrm.Si^2);
    
    % max(0,x) returns 0 if x is NaN (not included in experiment)
    s.Na = max(0,data.NaERR)/100*max(0,catnrm.Na); 
    s.K  = max(0,data.KERR) /100*max(0,catnrm.K);
    s.Ca = max(0,data.CaERR)/100*max(0,catnrm.Ca);
    s.Al = max(0,data.AlERR)/100*max(0,catnrm.Al);
    s.Si = max(0,data.SiERR)/100*max(0,catnrm.Si);
    
    s.M = sqrt( ...
          dM.dNa^2*s.Na^2 + dM.dK^2*s.K^2 + dM.dCa^2*s.Ca^2 + dM.dAl^2*s.Al^2 + dM.dSi^2*s.Si^2 ...
          );
    M(iSample,2) = s.M;
    % calculate zircon saturation temperature, Zr.zrn and Zr.gls are in
    % umol/mol. For researchers who report ZrO2 wt%, we calculate the
    % normalized ZrO2 in mol then times 10^6. For researchers who report Zr
    % in ppm (ug/g), we convert Zr (ug/g) back to wt%,
    % then divide by Zr molar mass, add other oxides mols and get
    % normalized mols for Zr, add 2 mols for O. Then times the total mols
    % of ZrO2 by 10^6. 

    Zr.zrn = 500000; % ZrO2 concentration in zircon, umol/mol
    
    if ~isnan(molpct.ZrO2a) % if Zr is given as ZrO2 wt %
        Zr.gls = molnrm.Zra*1e6; % for researchers who report ZrO2 (wt%), ZrO2 conc in umol/mol in melt
        Zr.pctErr = data.ZrERR;
    else
        Zr.gls = molnrm.Zrb*1e6; % for researchers who report Zr(ug/g), ZrO2 conc in umol/mol in melt
        Zr.pctErr = data.ZrPpm1Sig/Zr.gls * 100;
    end
    
    Zr.D   = Zr.zrn / Zr.gls; % mineral/melt distribution coefficient
    Zr.lnD = log(Zr.D); % log(D)
    
    % equation 2 from Boehnke et al. zircon saturation temperature
    % calculation, these are the best fit parameters and uncertainties from
    % their equation 2 (reported unct are 1sigma absolute)
    a = 10108;
    s.a = 32;
    b = 1.16;
    s.b = 0.15;
    c = 1.48;
    s.c = 0.09;
    T(iSample,1) = a / (Zr.lnD+b*(Mi-1)+c); %eqn 2
    
    % linear uncertainty propagation for T, assuming % unct in Na from probe = % unct
    % in renomalized cation abundance, using uncertainties in M, DZr
    % (Boehnke et al 2013, equation 3)
    
    s.Zr  = Zr.gls * Zr.pctErr/100; % 1-sigma absolute unct in glass Zr conc (in ppm)
    s.DZr = s.Zr*Zr.D / Zr.gls; % equation 3 from Boehnke (their sigma_Zr)
    
    % partial derivatives of zircon staturation temp T wrt parameters in
    % eqn 2
    dT.da    = 1 /(Zr.lnD + b*(Mi-1) + c);
    dT.dDZr = -a / (Zr.D*(Zr.lnD + b*(Mi-1) + c))^2;
    dT.db    = a*(Mi-1) / (Zr.lnD + b*(Mi-1) + c)^2;
    dT.dM    = a / (Zr.lnD + b*(Mi-1) + c)^2;
    dT.dc    = a / (Zr.lnD + b*(Mi-1) + c)^2;
    
    T(iSample,2) = sqrt( ...
        dT.da^2*s.a^2 + dT.db^2*s.b^2 + dT.dc^2*s.c^2 + ...
        dT.dDZr^2*s.DZr^2 + dT.dM^2*s.M^2 ...
        );
    
    % extract SiO2 and DU information as well
    SiO2(iSample) = data.SiO2;
    DU(iSample) = data.DUMCWGlsStdErr;
    DTh(iSample) = data.DThMCWGlsStdErr;
    
    % fill in covariance and Jacobian matrices
    % according to notes on 6/30/21 and 7/1/21 - Noah's OneNote files
    
    % S.Tin is the covariance matrix for the inputs to calculate T
    S.Tin(iSample,iSample) = s.DZr^2;
    S.Tin(iSample+nSamples, iSample+nSamples) = s.M^2;
    S.Tin(2*nSamples+(1:3), 2*nSamples+(1:3)) = diag([s.a s.b s.c].^2);
    
    % J is the Jacobian matrix with partial derivatives of temperature
    % inputs with respect to temperature, T = a/(log(DZr)+b*(M-1)+c)
    J(iSample, iSample) = dT.dDZr;
    J(iSample, iSample+nSamples) = dT.dM;
    J(iSample, 2*nSamples+1) = dT.da;
    J(iSample, 2*nSamples+2) = dT.db;
    J(iSample, 2*nSamples+3) = dT.dc;
    
    %S.SiO2 is the covariance matrix for SiO2 (wt% oxide) uncertainties
    S.SiO2(iSample, iSample) = (data.SiERR * data.SiO2 / 100)^2;
    
    %S.DU is the covariance matrix for DU uncertainties
    S.DU(iSample, iSample) = data.DUErrprWGlsStdErr^2;
    
end % for iSample = 1:nSamples

S.T = J*S.Tin*J';
S.TSiO2DU = blkdiag(S.T, S.SiO2, S.DU);



%% clean up

clear a b c catnrm catpct catpctSum catpctVec dM dT iSample Mi mm nSamples Zr s molpctVec molpctzir molpctSumVec molpctzirVec DU DTh DThDU
%molpctSum molregls molreZir data
